from prettytable import PrettyTable


def func(x1, x2):  # Функция вывода значения функции согласно входным координатам x1 и x2
    return round(eval(F), roundnum)


def dircheck(x1, x2):
    # Функция вывода новых координат и значения функции в направлении вектора движения по новым и старым координатам
    out = [round(x1 + 2 * (x1 - tab[-2][0]), roundnum),
           round(x2 + 2 * (x2 - tab[-2][1]), roundnum),
           func(round(x1 + 2 * (x1 - tab[-2][0]), roundnum),
                round(x2 + 2 * (x2 - tab[-2][1]), roundnum))]
    return out


def hjiteration():
    global h, x1p, x2p, tab, iteramount  # Объявляем внутри функции глобальные переменные
    iteramount += 1  # Добавляем единицу к счётчику итерций
    localtab = []  # Создаём локальную таблицу для записи результата поиска по шагу
    for x1var in x1p, round(x1p + h, roundnum), round(x1p - h, roundnum):
        for x2var in x2p, round(x2p + h, roundnum), round(x2p - h, roundnum):
            localtab.append([x1var, x2var, func(x1var, x2var)])
    # Записываем в локальную таблицу все координаты и значения функции при всех возможных шагах
    localtab = min(localtab, key=lambda n: n[2])  # Находим минимальное значение функции при всех возможных шагах
    if localtab[2] < tab[-1][2]:  # Если результат поиска по шагу успешен
        tab.append(localtab)  # Добавляем значение в основную таблицу
        vectorcheck = dircheck(localtab[0], localtab[1])  # Проводим поиск по направлению
        if vectorcheck[2] < localtab[2]:  # Если новое значение функции меньше предыдущего
            tab.append(vectorcheck)  # Добавляем значение в основную таблицу
    else:  # Если результат поиска по шагу не успешен
        h /= d  # Уменьшаем значение шага
    x1p, x2p = tab[-1][0], tab[-1][1]  # Фиксируем значения переменных, беря данные из основной таблицы


e = 0.0001  # Точность
h = 0.2  # Шаг
d = 2  # Коэфициент уменьшения шага
x1p = 1  # Изначальная координата x1
x2p = 1  # Изначальная координата x2
iteramount = 0  # Счётчик итераций
roundnum = 14  # Округление после запятой для избежания ошибки с плавающей точкой
# F = '7*x1**2+2*x1*x2+5*x2**2+x1-10*x2'  # Целевая функция
# F = '3 *x1**2  - 3* x1 * x2 + 4 * x2**2 - 2* x1 + x2'  # Целевая функция
F = '7*x1**2+2*x1*x2+5*x2**2+x1-10*x2'
tab = [[x1p, x2p, func(x1p, x2p)]]  # Ввод в таблицу нулевой точки согласно входным данным
print('\nЦелевая функция: F(x1, x2)=' + F + '\n')  # Вывод целевой функции
while h >= e:  # Пока шаг меньше или равен точности
    hjiteration()  # Выполняем итерации
table = PrettyTable(['Точка', 'X1', 'X2', 'Значение функции'])  # Вводим заголовки столбцов таблицы с выводом
for s in tab:  # Каждый элемент таблицы tab
    table.add_row(['X(' + str(tab.index(s)) + ')', s[0], s[1], s[2]])  # Записываем в таблицу, добавляя номер точки
print(table)  # Выводим таблицу
print('\nИтераций произведено: ' + str(iteramount))  # Выводим количество итераций
